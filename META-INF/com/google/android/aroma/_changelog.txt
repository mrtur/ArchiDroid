ArchiDroid 2.3.9

- [!] Compiled with Linaro GCC 4.8.3 (14.02)
# The long fight between Linaro and default GCC toolchain is still present
# We already had a few ArchiDroid releases with Linaro and definitely the most of them with default GCC
# While you probably won't tell me if Linaro makes a difference, I'll tell you that GCC version does
# Everybody agrees that ArchiDroid compiled with GCC 4.8 is way faster than the one compiled with GCC 4.7
# The choice is between very often updated Linaro in current 4.8.3 version, and rarely updated Google's GCC toolchain in current 4.8.1 version
# Considering the fact that Linaro has all GCC commits and in addition to that some unique ones, which may, or may not, make a difference, I'd still choose the toolchain, which is more recent
# Personally I also feel that ArchiDroid is smoother when compiled with Linaro, but this may be due to updated GCC version (only) or a common placebo effect
# Anyway, it's up to you to decide if it makes a difference or not. Definitely it's not worse and we should ask "why we shouldn't use Linaro" instead of "why we should"
# I decided that even if Linaro doesn't make a difference, GCC update does and I'll compile ArchiDroid using latest released Linaro, as long as we won't face any problems
# If not because of Linaro, then at least because of updated GCC upstream, which is proven to make a difference
# This is the final decision, at least until I find a very good reason to reexamine this change. ArchiDroid is about tweaking, and Linaro definitely helps in that

- [!] Further ArchiDroid 2.X optimizations
* Placed each function and data item into its own section, this is required for below optimization (-ffunction-sections -fdata-sections)
* Enabled garbage collection of unused input sections (-Wl,--gc-sections)
* By enabling the two above options we've got binaries stripped from unused functions and variables, which (should) result in reduced load times and improved performance

- [!] Implemented ARCHIDROID_CRON
* ArchiDroid's Dnsmasq Hook (Wi-Fi Tethering) is now handled by ARCHIDROID_CRON
* ArchiDroid's DNS Daemon is now handled by ARCHIDROID_CRON
* Implemented PROCESS_MONITOR for all ARCHIDROID_INIT processes, only dnsproxy2 is active by default # This fixes rare "no network" issue reported by some AD 1.X users

- BACKEND: Added inotify-tools (inotifywait & inotifywatch commands)
- BACKEND: Recompiled common ArchiDroid binaries (haveged, dnsmasq, dnsproxy2, pixelserv) to latest versions, added SGS3-optimizations including NEON
- BACKEND: Optimized dnsmasq and dns daemon - changing of local DNSes doesn't require restarting of backend anymore
- Added AGNi kernel developed by @psndna88
- Removed Temasek kernel # I consider it more or less EOL, especially because Temasek focuses on Note3 and definitely will not spend any more time on his kernel for SGS3
- Updated Boeffla kernel to 2.2-beta6a
- Updated Googy Max kernel to 2.1.8
- Updated Android Terminal Emulator to 1.0.57
- Updated MX Player to 1.7.25
- Updated Cool Tool to 5.4
- Updated PhilZ Touch recovery to 6.19.3
- Updated sources


[ ON HOLD ]
* From now on, ArchiDroid 2.X is compiled with optimization for speed for all targets (arm and thumb) (-O2)
# In general we have 3 candidates for optimization level - optimize for speed (O2), optimize for speed yet more (O3) and optimize for size (Os)
# By default target ARM (low-level binary code, about 10% of Android) is compiled with O2, and target THUMB (90% of Android) is compiled with Os
# These flags have been set back in Android gingerbread/froyo times, when we were low on RAM, low on raw I/O and low on CPU, but they're still recent and active
# I made bunch of tests to make a final statement on what gives the best results nowadays
# Os gives up to 20% smaller code and up to 5x slower code compared to O2
# In most cases Os saves no more than 10% of code size, and effects in about 3x slower code compared to O2
# O3 gives up to 80% bigger code and up to 1.5x faster code compared to O2
# In most cases, O3 gives about 50% larger binary, and effects in no more than a few percent faster code compared to O2
# These values were determined by me in a bunch of C/C++ benchmarks, with one being shared by me on xda
# However, due to the fact that Android is an operating system and not a benchmark, we need to think about speed of the code, but also about a memory and cpu cache (size of the code)
# In practice, O2 results in about 6MB bigger /system partition, but keeping in mind the number of combined files, this is no more than a few percent of size increase per each binary
# However, thanks to O2 flag, all binaries and the whole OS is now much faster, this is due to the fact that Os does not optimize for cpu cache or memory, but for the plain code size
# which results in code being much slower than usual, because we're trying to make smallest possible code instead of giving freedom to GCC, and optizimizing speed/size accordingly